using Robust.Client.AutoGenerated;

using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;
using Robust.Client.UserInterface;
using Content.Client.Stylesheets;
using static Robust.Client.UserInterface.Controls.BaseButton;
using static Robust.Client.UserInterface.Controls.BoxContainer;

namespace Content.Client.PlayingCard.UI
{
    [GenerateTypedNameReferences]
    public partial class PlayingCardHandWindow : DefaultWindow
    {
        [Dependency] private readonly IResourceCache _resourceCache = default!;
        [Dependency] private readonly IPrototypeManager _prototypeManager = default!;

        private PlayingCardHandBoundUserInterface Owner { get; }

        private List<String> _cachedCardList = new();

        private int _cardOffset = 0;

        private int _cardPageLimit = 5;
        public PlayingCardHandWindow(PlayingCardHandBoundUserInterface owner)
        {
            IoCManager.InjectDependencies(this);
            RobustXamlLoader.Load(this);

            Owner = owner;
            IoCManager.Resolve<IResourceCache>();
            // VendingContents.OnItemSelected += ItemSelected;

            // GRAB SPRITES
            // EntityView.Sprite = IoCManager.Resolve<IEntityManager>().GetComponent<SpriteComponent>(component.Owner);
        }

        public void Populate(List<String> cardList)
        {
            // SHOULDN'T BE REMOVING ALL CHILDREN EVERYTIME, ONLY SHIFT
            CardList.RemoveAllChildren();

            _cachedCardList = cardList;

             // ONLY START OFFSETTING IF CARDCOUNT > PAGE LIMIT
            int start = Math.Max(0, ((cardList.Count - 1) - _cardOffset));
            int end = Math.Max(0, ((start + 1) - _cardPageLimit));

            for (int i = start; i >= end ; i--) {

            var button = new CardButton
            {
                CardName = cardList[i],
                Index = i // We track this index purely for debugging.
            };

            // var rect = button.EntityTextureRects;
            // rect.Textures = SpriteComponent.GetPrototypeTextures(prototype, resourceCache).Select(o => o.Default).ToList();
                button.ActualButton.OnPressed += OnCardSelected;
                button.CardNameLabel.Text = cardList[i];
                CardList.AddChild(button);
            }

            // IF NO CHNAGES, DOnn"T DO ANYTHING, OTHERWISE IF OFFSET CHANGED, DELETE FAR LEFT, AMMEND ONE TO RIGHT.

        }

        private void ShiftCardsLeft()
        {

        }

        private void ShiftCardsRight()
        {

        }

        protected override void MouseWheel(GUIMouseWheelEventArgs args)
        {
            if (!((_cachedCardList.Count - 1) < _cardPageLimit))
            {
                base.MouseWheel(args);
                var newOffset = _cardOffset + args.Delta.Y;
                if ((newOffset < 0) || (newOffset > _cachedCardList.Count - 1))
                    return;

                _cardOffset = (int)newOffset;
                Populate(_cachedCardList);
                args.Handle();
                return;
            }
            if (_cardOffset > 0)
                _cardOffset = 0;
        }

        private void OnCardSelected(BaseButton.ButtonEventArgs args)
        {
            var item = (CardButton) args.Button.Parent!;
            Owner.RemoveCard(item.Index);
        }

        private sealed class CardButton : Control
        {
            public string CardName { get; set; } = default!;
            public Button ActualButton { get; private set; }
            public Label CardNameLabel { get; private set; }
            public Label DescriptionLabel { get; private set; }
            public LayeredTextureRect EntityTextureRects { get; private set; }
            public int Index { get; set; }

            public CardButton()
            {
                AddChild(ActualButton = new Button
                {
                });

                AddChild(new BoxContainer
                {
                    Orientation = LayoutOrientation.Vertical,
                    MinSize = (100, 50),
                    Children =
                    {
                        (EntityTextureRects = new LayeredTextureRect
                        {
                            MinSize = (32, 32),
                            HorizontalAlignment = HAlignment.Center,
                            VerticalAlignment = VAlignment.Center,
                            Stretch = TextureRect.StretchMode.KeepAspectCentered,
                            CanShrink = true
                        }),
                        (CardNameLabel = new Label
                        {
                            VerticalAlignment = VAlignment.Center,
                            HorizontalAlignment = HAlignment.Center,
                            HorizontalExpand = true,
                            Text = "Backpack",
                        }),
                        (DescriptionLabel = new Label
                        {
                            VerticalAlignment = VAlignment.Center,
                            HorizontalAlignment = HAlignment.Center,
                            HorizontalExpand = true,
                            Text = "A playing card",
                        })
                    }
                });
            }
        }

        public class EntityContainerButton : ContainerButton
    {
        public string CardName;

        public EntityContainerButton(string cardName)
        {
            CardName = cardName;
            AddStyleClass(StyleNano.StyleClassStorageButton);
        }
    }
    }
}
